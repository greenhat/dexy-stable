\documentclass{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\usepackage{systeme}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Amitabh notes}}{#1}}}

\usepackage[dvipsnames]{xcolor}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

%\newcommand{\bruno}[1]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen]{#1}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{flushend}

%\usepackage{xcolor}

\newcommand{\bc}{ERG}
\newcommand{\stc}{stablecoin}
\newcommand{\sct}{stablecoin}
\newcommand{\dx}{Dexy}

\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\state}{state}

\newcommand{\ignore}[1]{} 
\newcommand{\full}[1]{}
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}}

\begin{document}

\title{Dexy - A Stablecoin With Algorithmic Bank Interventions}
\author{Alexander Chepurnoy, Amitabh Saxena}


\maketitle

\begin{abstract}
In this paper, we consider a new stablecoin design called \em{Dexy}.
\end{abstract}

% \input{intro}

\section{Introduction}

Algorithmic stablecoins is a natural extension of cryptocurrencies, trying to 
solve problems with volatility of their prices by pegging stablecoin price to an
asset which price believed to be more or less stable with time (e.g. 1 gram of gold).  

Stable pricing could be useful for:
\begin{enumerate}
\item securing fundraising; a project can be sure that funds collected during fundraising will have stable value in the mid- and long-term.
\item doing business with predictable results. For example, a hosting provider can be sure that payments collected at the beginning of the month 
      would be about the same at the end of the month when the provider will need to pay the bills. 
\item shorting: when cryptocurrency prices are high, it is desirable for investors to rebalance their portfolio by increasing exposure to fiat currencies (or traditional
 commodities). However, as KYC procedures are often cumbersome or not possible, it would be better to buy fiat and commodity substitues in form of stablecoins on decentralized exchanges.
\item lending and other decentralized finance applications. Stability of asset value is critical for many applications.
\end{enumerate}

Algorithmic stablecoins are different from centralized stablecoins, such as USDT and USDC, which are 
convertible into underlying (pegged asset) via a trusted party. In case of an algorithmic stablecoin, its 
pegging is done via rebasement of total supply, or via imitating the trusted party, which holds. 


\section{General Design}

Unlike popular algorithmic stablecoins based on two tokens (instruments), \dx{} is based on one token but two protocols. In the first place, 
there is market where trading of \dx{} vs the base currency (\bc{}) happens. In the second place, if market price is way too different from target price (reported by an oracle), there is an algorithmic central bank which makes interventions. The central bank can also mint new \dx{} tokens, selling them for \bc{}. The bank is using reserves in \bc{} it is buying for interventions then. 

As a simple solution for the market, we are using constant-factor Automated Market Maker (CF-AMM) liquidity pool, similar to ErgoDEX and UniSwap. The pool has \bc{} on one side and \dx{} on another. For CF-AMM pool, multiplication of \bc{} and \dx{} amounts before and after a trade should be preserved, so $e * u = e' * u'$, where $e$ and $u$ are amounts of \bc{} and \dx{} in the pool before the trade, and $e'$ and $u'$ are amounts of \bc{} and \dx{} in the pool after the trade. It is also possible to put liquidity into the pool, and remove liquidity from it. 

The bank has two basic operations. It can mint new \dx{} tokens and 

Now we are going to consider how to put restrictions and design rules for the system to have stable price of \dx{}. 

\section{Stability}

What provides stability for the stablecoin when we have the design sketched in the previous section? 

\section{Worst Scenario and Bank Reserves}

The bank is doing interventions when the situation is far from normal on the markets, and enough time passed for markets to stabilize themselves with no interventions. In our case, the bank is doing interventions based on stablecoin price in the liquidity pool in comparison with oracle provided price~(we can assume that price on other markets is similar to liquidity pool\'s due to arbitrage). The bank\'s intervention then is about injecting its \bc{} reserves into the pool.  

We start with introducing notation: 
\begin{itemize}
  \item{} $T$ - period before intervention starts. After one intervention the bank can start another one after $T$. 
  \item{} $p$ - price reported by the oracle at the moment (for example, 20 USD per ERG)
  \item{} $s$ - price which the bank should stand in case of price crash. For example, we can assume that $s = \frac{p}{4}$ (so if p is 20 USD per ERG, then $s$ is 5 USD per ERG, means the bank needs to have enough reserves to save the markets when the price is crashing from 20 to 5 USD per ERG)
  \item{} $R$ - ratio between $p$ and $s$, $R = \frac{p}{s}$
  \item{} $e$ - amount of \bc{} in the liquidity pool 
  \item{} $u$ - amount of \stc{} in the liquidity pool
  \item{} $O$ - amount of \stc{} outside the liquidity pool. The distribution in $O$ is not known for the \dx{} protocol.
  \item{} $E$ - amount of \bc{} in the bank. 
  \item{} $r$ - ratio between $p$, and price in the pool, which is $\frac{u}{e}$, thus $r = \frac{p}{\frac{u}{e}} = \frac{p*e}{u}$
\end{itemize}  

Note that current price in the pool is $\frac{u}{e}$. 

First of all, let's assume that price crashed from $p$ to $s$ sharply and stands there, and before the crash there were $e$ of \bc{} and $u$ of \sct{}, respectively, with liquidity pool price being $p$. The worst case is when no liqudity put into the pool during the period $T$. With large enough $T$ and large enough $R$ this assumption is not very realistic probably: liquidity will be put into the pool by arbitrage players, price is failing with swings where traders will mint \sct{} by putting \bc{} into bank reserves, and so on. However, it would be reasonable to consider worst-case scenario, then in the real world \dx{} will be even more durable than in theory. 

In this case, the bank must intervene after $T$ units of time, as the price differs significantly, and restore the price in the pool, so set it to $s$. We denote amounts of \bc{} and \sct{} in the pool after the intervention as $e'$ and $u'$, respectively. Then:

\begin{itemize}
  \item{} $e * u = e' * u'$
  \item{} as the bank injects $E_1$ ergs into the pool, $e' = e + E_1$
  \item{} $\frac{u'}{e'} = s$, thus $u' = s * (e + E_1)$ 
  \item{} from above, $E_1 = \sqrt{\frac{e * u}{s}} - e$
\end{itemize}

So by injecting $E_1$ \bc{}, the bank recovers the price. However, this is not enough, as now there are $O$ \sct{} units which can be injected into the pool from outside. 
Again, in the real life it is not realistic to assume that all the $O$ \sct{} would be injected, as some of them are simply lost. However, we need to assume worst-case scenario. We also assume that those $O$ tokens are being sold in very small batches not significantly affecting price in the pool, and after each batch seller of a new batch is waiting for a bank intervention to happen (so for $T$ units of time), and sells only after the intervention. In this case all the $O$ tokens are being sold at price close to $s$, so the bank should have $E_2 = \frac{O}{s}$. We note that this scenario is also not realistic and takes very long time. However, as before we assume the absolutely worst case.

Summing up $E_1$ and $E_2$, we got \bc{} reserves the bank should have to be ready for worst-case scenario: $E_w = E_1 + E_2 = \sqrt{\frac{e * u}{s}} - e + \frac{O}{s}$.

\section{Minting Rules}

Based on needed reserves for worst-case scenario estimation, we can consider minting rules accordingly. Similarly to SigUSD~(a Djed instantiation), we can, for example, target for security in case of 
4x price drop, so to consider $R = \frac{p}{s} = 4$, and allow to mint \sct{}~while there are enough \bc{}~in reserves, so while there are not less than $E_w$ \bc{} in reserves. However, in this case most of time \sct{} would be non-mintable, and only during moments of \bc{} price going up significantly it will be possible to mint. 

Thus we leave worst-case scenario for UI, so dapps working with the \dx{} may show level of reserves, in comparison with worst-case scenario estimations. In this case, having on-chain data analysis, 
more precise estimations of reserve quality can be made~(by considering \sct{} locked in DeFi protocols, likely forgotten, etc).

We are proposing following minting rules.  

\begin{itemize}
  \item{Arbitrage mint: } if price reported by the oracle is higher than in the pool, i.e. $p > \frac{u}{e}$, we allow to print enough \sct{} to bring the price to $p$. That is, the bank allows to mint up to $\delta_u = \sqrt{p*e*u}-u$ \sct{} by accepting up to $\delta_e = \frac{\delta_u}{p}$ \bc{}s into reserves. 

  \em{To instantiate the rule, we can allow for arbitrage minting if the price $p$ is more than $\frac{u}{e}$ by at least 1\% for time period $T_{arb}$ (e.g. 1 hour), also, the bank is chargin 1\% fee 
  for the operation.} 

  \item{Free mint: } we allow to mint up to $\frac{u}{100}$ \sct{}s within time period $T_{free}$. 
  \em{To instantiate the rule, we propose to have bank fee of 1\%, and allow for free mint if $0.98 < r < 1.02$}.
\end{itemize}  


\begin{itemize}
   \item{Intervention: } if reported by the oracle is lower than in the pool by significantly enough margin, i.e. $\frac{p*e}{u} < r$, where $r$ is some constant which is hard-wired into the protocol, then the bank is providing \bc{}s. to restore the price.
   \em{To instantiate the rule, we propose to allow the bank to intervene if $r <= 0.98$ for time period $T_{int}$}
   \item{Payout: } if bank has too much reserves, so $E > E_w$, we can allow for paying excess reserves out. There could be different ways to do this. E. g. extra reserves can be paid to holders of
   liquidity pool LP tokens.
\end{itemize}

\begin{itemize}
   \item{Burn: } if the bank if empty, and $r$ is below threshold, it is allowed to burn \sct{}s in the pool. 
   \em{To instantiate the rule, we propose to \sct{} burn if $r <= 0.95$ for time period $T_{burn}$}
\end{itemize}

\section{Notes on stability}
 
\knote{fill the section}

\section{Implementation}

\knote{put contracts here}

\section{Simulations}
We made simulations. \knote{finish}

\section{Extensions}


%\input{intro-props}
%\input{intro-scorex}
%\input{intro-contrib}
%\input{related-work}
%\input{intro-org}
%\input{sec-scorex}
%\input{sec-props}
%\input{sec-examples}
%\input{conclusion}

\section*{Acknowledgments}

Authors would like to thank.

\bibliographystyle{IEEEtran}
\bibliography{sources, ref}

%Appendices

%\newpage
%\appendix
%\input{apx-tests}


\end{document}
