\documentclass{article}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}

\usepackage{systeme}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Amitabh notes}}{#1}}}

\usepackage[dvipsnames]{xcolor}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

%\newcommand{\bruno}[1]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen]{#1}}

% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{flushend}

%\usepackage{xcolor}

\newcommand{\bc}{ERG}
\newcommand{\stc}{stablecoin}
\newcommand{\sct}{stablecoin}
\newcommand{\dx}{Dexy}

\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\state}{state}

\newcommand{\ignore}[1]{} 
\newcommand{\full}[1]{}
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}}

\begin{document}

\title{Dexy - A Stablecoin With Algorithmic Central Bank}
\author{Alexander Chepurnoy, Amitabh Saxena}


\maketitle

\begin{abstract}
In this paper, we consider a new stablecoin protocol design called \dx. The protocol has two mandatory components, reference market~(in form of liquidity pool where anyone can 
trade base currency against stable coins), and an algorithmic central bank, which is responsible for new stablecoins issuance, and also for stabilizing stablecoin price in the reference market. 
\end{abstract}

% \input{intro}

\section{Introduction}

Algorithmic stablecoins is a natural extension of cryptocurrencies, trying to 
solve problems with volatility of their prices by pegging stablecoin price to an
asset which price is considered to be more or less stable with time (e.g. gold).  

Having an asset with a stable value could be useful for:
\begin{itemize}
\item securing fundraising; a project can be sure that funds collected during fundraising will have stable value in the mid- and long-term.
\item doing business with predictable results. For example, a shop can be sure that funds collected from sales will be about the same when the shop is ordering goods from warehouses~(otherwise, the shop may go bankrupt if margin is not that big). 
\item shorting: when cryptocurrency prices are high, it is desirable for investors to rebalance their portfolio by increasing exposure to fiat currencies (or traditional
 commodities). However, as fiat currencies and centralized exchanges impose significant risks, it would be better to buy fiat and commodity substitues in form of stablecoins on decentralized exchanges.
\item lending and other decentralized finance applications. Stability of collateral value is critical for many applications.
\end{itemize}

Algorithmic stablecoins are different from centralized stablecoins, such as USDT and USDC, for which there is a trusted party doing conversions to a pegged asset. In case of an algorithmic stablecoin, the 
pegging is done via rebasement of total supply~(as in Ampleforth), or via imitating the trusted party, which holds reserves and doing market interventions when it is needed for getting exchange rate back to the peg. Imititating the trusted party is usually done by allowing anyone on the blockchain creating over-collateralized financial instruments, such as collateralized debt positions~(as 
in DAI) or zero-coupon bonds~(as in the Yield protocol).

\knote{add links to the paragraph above}

In this work we present \dx{}, a stablecoin protocol where the bank presented explicitly as a contract with few predefined rules. The bank is trying to stabilize stablecoin value on the markets, using a liquidity pool as a reference market, by providing stablecoin liquidity, when stablecoin is over the peg, or injecting base currency from its reserves, when the stablecoin is under the peg. In extreme case, when bank reserves are depleted and stablecoin is still under the peg, its value is restored by burning stablecoin in the liquidity pool. In some aspects \dx{} could resemble Fei or Gyroscope. \knote{make comparison subsection}  


\section{\dx{} Design in General}

Unlike popular algorithmic stablecoins based on two tokens, \dx{} is based on one token but two protocols. In the first place, 
there is reference market~(done as on-chain protocol), where trading of \dx{} vs the base currency (\bc{}) happens. In the second place, if market price is way too different from target price (as reported by a trusted oracle), there is an algorithmic central bank which is doing interventions in order to readjust the market price~(so make it closer to the oracle's one). The central bank can also mint new \dx{} tokens, selling them for \bc{}. The bank is using reserves in \bc{} it is buying for interventions then. 

As a simple solution for the {\em reference market}, we are using constant-product Automated Market Maker (CP-AMM) liquidity pool, similar to ErgoDEX and UniSwap. The pool has \bc{} on one side and \dx{} on another. For CP-AMM pool, multiplication of \bc{} and \dx{} amounts before and after a trade should be preserved, so $e * u = e' * u'$, where $e$ and $u$ are amounts of \bc{} and \dx{} in the pool before the trade, and $e'$ and $u'$ are amounts of \bc{} and \dx{} in the pool after the trade, correspondingly. As for any CP-AMM pool, it is possible to put liquidity into the pool, and remove liquidity from it, however, there are some limitations here for \dx{} reference market we're going to uncover further. 

The bank has two basic operations. It can mint new \sct{} tokens per request, using trusted oracle's price, by accepting \bc{} in its reserves. It also can intervene into markets by providing \bc{} from reserves when needed~(namely, when price in the pool $\frac{u}{e}$ is significantly different from price on external markets $p$ which reported by oracle).

Now we are going to consider how to put restrictions and design rules for the system to ensure stable pricing for \sct{} tokens. 

\section{Notation}

We start with introducing notation: 
\begin{itemize}
  \item{} $T$ - period before intervention starts. After one intervention the bank can start another one after $T$. 
  \item{} $p$ - price reported by the oracle at the moment (for example, 20 USD per ERG)
  \item{} $s$ - price which the bank should stand in case of price crash. For example, we can assume that $s = \frac{p}{4}$ (so if p is 20 USD per ERG, then $s$ is 5 USD per ERG, means the bank needs to have enough reserves to save the markets when the price is suddenly crashing from 20 to 5 USD per ERG)
  \item{} $R$ - ratio between $p$ and $s$, $R = \frac{p}{s}$
  \item{} $r$ - ratio between $p$, and price in the pool, which is $\frac{u}{e}$, thus $r = \frac{p}{\frac{u}{e}} = \frac{p*e}{u}$
  \item{} $e$ - amount of \bc{} in the liquidity pool 
  \item{} $u$ - amount of \stc{} in the liquidity pool
  \item{} $O$ - amount of \stc{} outside the liquidity pool. The distribution in $O$ is not known for the \dx{} protocol, but the bank can easily store how many \sct{} tokens were minted and then get $O$ by deducting $u$ from it.
  \item{} $E$ - amount of \bc{} in the bank. 
\end{itemize}  

\section{Worst Scenario and Bank Reserves}

The bank is doing interventions when the situation is far from normal in the markets, and enough time passed for markets to stabilize themselves with no interventions. In our case, the bank is doing interventions based on stablecoin price in the liquidity pool in comparison with oracle provided price. The bank's intervention then is about injecting its \bc{} reserves into the pool.  

First of all, let's assume that price crashed from $p$ to $s$ sharply and stands there, and before the crash there were $e$ of \bc{} and $u$ of \sct{}, with liquidity pool price being $p$. The worst case is when no liqudity put into the pool during the period $T$. With large enough $T$ and large enough $R$ this assumption is not very realistic probably: liquidity will be put into the pool by arbitrage players, price is failing with swings where traders will mint \sct{} by putting \bc{} into bank reserves, and so on. However, it would be reasonable to consider worst-case scenario, then in the real world \dx{} will be even more durable than in theory. 

In this case, the bank must intervene after $T$ units of time, as the price differs significantly, and restore the price in the pool, so set it to $s$. We denote amounts of \bc{} and \sct{} in the pool after the intervention as $e'$ and $u'$, respectively. Then:

\begin{itemize}
  \item{} $e * u = e' * u'$
  \item{} as the bank injects $E_1$ ergs into the pool, $e' = e + E_1$
  \item{} $\frac{u'}{e'} = s$, thus $u' = s * (e + E_1)$ 
  \item{} from above, $E_1 = \sqrt{\frac{e * u}{s}} - e$
\end{itemize}

So by injecting $E_1$ \bc{}, the bank recovers the price. However, this is not enough, as now there are $O$ \sct{} units which can be injected into the pool from outside. 
Again, in the real life it is not realistic to assume that all the $O$ \sct{} would be injected, as some of them are simply lost. However, we need to assume worst-case scenario. We also assume that those $O$ tokens are being sold in very small batches not significantly affecting price in the pool, and after each batch seller of a new batch is waiting for a bank intervention to happen (so for $T$ units of time), and sells only after the intervention. In this case all the $O$ tokens are being sold at price close to $s$, so the bank should have $E_2 = \frac{O}{s}$. We note that this scenario is also not realistic and takes very long time. However, as before we assume the absolutely worst case.

Summing up $E_1$ and $E_2$, we got \bc{} reserves the bank should have to be ready for worst-case scenario: $E_w = E_1 + E_2 = \sqrt{\frac{e * u}{s}} - e + \frac{O}{s}$.

It is simple to see why this scenario is worst-case for the bank. In this scenario, the bank is buying all the $O$ of external $\sct{}$ at the worst possible price $s$, and get to this price by burning its own reserves only.  

\section{Bank and Pool Rules}

Based on needed reserves for worst-case scenario estimation, we can consider minting rules accordingly. Similarly to SigUSD~(a Djed instantiation), we can, for example, target for security in case of 
4x price drop, so to consider $R = \frac{p}{s} = 4$, and allow to mint \sct{}~while there are enough \bc{}~in reserves, so while there are not less than $E_w$ \bc{} in reserves. However, in this case most of time \sct{} would be non-mintable, and only during moments of \bc{} price going up significantly it will be possible to mint. 

Thus we leave worst-case scenario for UI, so dapps working with the \dx{} may show level of reserves, in comparison with worst-case scenario estimations. In this case, having on-chain data analysis, 
more precise estimations of reserve quality can be made~(by considering \sct{} locked in DeFi protocols, likely forgotten, etc).

We are proposing following minting rules.  

\begin{itemize}
  \item{Arbitrage mint: } if price reported by the oracle is higher than in the pool, i.e. $p > \frac{u}{e}$, we allow to print enough \sct{} to bring the price to $p$. That is, the bank allows to mint up to $\delta_u = \sqrt{p*e*u}-u$ \sct{} by accepting up to $\delta_e = \frac{\delta_u}{p}$ \bc{}s into reserves. 

  \em{To instantiate the rule, we can allow for arbitrage minting if the price $p$ is more than $\frac{u}{e}$ by at least 1\% for time period $T_{arb}$ (e.g. 1 hour), also, the bank is chargin 1\% fee 
  for the operation.} 

  \item{Free mint: } we allow to mint up to $\frac{u}{100}$ \sct{}s within time period $T_{free}$. 
  \em{To instantiate the rule, we propose to have bank fee of 1\%, and allow for free mint if $0.98 < r < 1.02$}.
\end{itemize}  

In addition to minting actions, which increase bank reserves only, we define following two actions which decrease them: 

\begin{itemize}
   \item{Intervention: } if reported by the oracle is lower than in the pool by significantly enough margin, i.e. $\frac{p*e}{u} < r$, where $r$ is some constant which is hard-wired into the protocol, then the bank is providing \bc{}s. to restore the price.
   \em{To instantiate the rule, we propose to allow the bank to intervene if $r <= 0.98$ for time period $T_{int}$}
   \item{Payout: } if bank has too much reserves, so $E > E_w$, we can allow for paying excess reserves out. There could be different ways to do this. E. g. extra reserves can be paid to holders of
   liquidity pool LP tokens.
\end{itemize}


We also state following rules for the liquidity pool (which, otherwise, acts as ordinary CP-AMM liquidity pool): 

\begin{itemize}
   \item{Stopping withdrawals: } if $r$ is below some threshold, withdrawals are stopped.  
   \em{To instantiate the rule, we propose to stop withdrawals immediately if $r <= 0.98$.}
   \item{Burn: } if the bank if empty, and $r$ is below some threshold, it is allowed to burn \sct{}s in the pool. 
   \em{To instantiate the rule, we propose to \sct{} burn if $r <= 0.95$ for time period $T_{burn}$. $T_{burn}$ must be quite big}
\end{itemize} 

\section{Stability}

What provides stability for the stablecoin when we have the design sketched in the previous sections? 
 
\knote{finish the section}

\section{Implementation}

\knote{put contracts here}

\section{Simulations}
We made simulations. \knote{finish}

\section{Extensions}


%\input{intro-props}
%\input{intro-scorex}
%\input{intro-contrib}
%\input{related-work}
%\input{intro-org}
%\input{sec-scorex}
%\input{sec-props}
%\input{sec-examples}
%\input{conclusion}

\section*{Acknowledgments}

Authors would like to thank.

\bibliographystyle{IEEEtran}
\bibliography{sources, ref}

%Appendices

%\newpage
%\appendix
%\input{apx-tests}


\end{document}
